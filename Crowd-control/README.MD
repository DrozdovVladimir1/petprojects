### Введение
Этот проект нацелен на помощь учёным-аналитикам в мониторинге скоплений людей в разных локациях. Проект предлагает сервис для загрузки фотографий с разных камер, сервис для подсчёта людей на фото и шкала для отображения данных.
### Структура проекта
Проект состоит их трёх сервисов: загрузка фото, подсчёт людей и шкала для отображения. Полная структура расположена ниже:
+ dashboard
  + client.html
    + Работает как фронт-енд часть сервиса
    + Делает запросы на бэкенд каждые 30 секунд для отображения счётчиков в шкалах
    + "Слушает" запросы от бэкенда
  + dashboard-deployment.yaml
    + Pod deployment файл (k8s), также содержит балансировщик загрузки
  + server.js
    + Бэкенд часть сервиса
    + "Слушает" запросы от "image-predict" сервиса
    + Хранит данные и отправляет "сообщения" фронту
  + package.json
+ image-predict
  + image-predict-deployment.yaml
    + Pod deployment файл (k8s), также содержит балансировщик загрузки
  + package.json
  + server.js
    + "Слушает" запросы от image-upload сервиса
    + Подсчитывает кол-во людей на фото
    + Отправляет результат на dashboard сервис вместе с фото
+ image-upload
  + image-upload-deployment.yaml
    + Pod deployment файл (k8s), также содержит балансировщик загрузки
  + package.json
  + server.js
    + Получает фото и отправляет на сервис image-predict
  + metric-server-components.yaml
### Выбор дизайна
Эта модель представляет как сервисы взаимодействуют между собой:
![image](https://github.com/DrozdovVladimir1/petprojects/assets/113205862/a475531e-24bc-4034-a9e7-620e39099ce5)
В модели существуют __отдельные__ для загрузки, подсчёта и отображения данных. Это сделано для того, чтобы в случае отказа одного из сервисов у нас был доступ к другим сервесам. Такая структура позволяет изолировать "краши".

Как можно видеть, все сервисы имеют балансировщик загрузки (load balancer). Во первых, он нужен для доступа к image-upload и dashboard сервисов. Image predict load balancer имеет load balancer так как мы хотим показать результат после подсчёта в этом сервисе. Во вторых, нам нужен сервис для "автоскейлинга". С его помощью сервисам не нужно знать определённый "порт" "пода" в случае увеличения нагрузки.

Взаимодействие сервисов представлено следующим образом: юзер отправляет запрос(ы) на image-upload; этот сервис отправляет запрос(ы) на image-predict, он в свою очередь отправляет запрос(ы) на dashboard. Такой тип взаимодействия позволяет показывать акутальные данные. Если image-predict сервис получит фото, но "крашнется" во время вычислений, мы не увидим изменений на dashboard сервисе.

Image upload сервис представляет собой API с одним "эндпоинтом" который отправляет информацию на image-predict.

Image predict сервис также является API. Сервис получает фото с n-ой камеры, подсчитывает кол-во людей. Более того, сервер подключен к "вебсокету" и отправляет сообщения после сбора информации.

Dashboard - "вебсокет". "Вебсокет" был выбран вместо API так как он позволяет отправлять сообщения на фронт как только сервис получает информацию от других сервисов. Также сервис может "слушать" сообщения от других сервисов и мгновенно реагировать. Помимо этого, каждые 30 секунд фронт запрашивает у бэкенда информацию по посчитанных за последние 30 секунд людей.

### Функционал
Приложение предоставляет способ загрузки фото с определённой камеры; отслеживать гистограмму кол-ва людей, подсчитанных за последние 30 секунд; панель подсчёта людей по камерам, которое позволяет увидеть последнее подсчитанное кол-во людей на фото и само фото; глобальный счётчик людей.

Приложение "автоскейлится" в случае если текущее кол-во ресурсов недостаточно для текущей нагрузки или слишком много ресурсов используется.

### Как установить
Для установки приложения, нужно ввести следующие команды:
```
dashboard$ docker build -t dashboard:v1 .
image-predict$ docker build -t image-predict:v1 .
image-upload$ docker build -t image-upload:v1 .
```
Далее нужно применить метрику серверных комнонентов:
```
root$ kubectl apply -f metric-server-components.yaml
```
После, нужно создать deplyoments и load balancers для каждого сервиса:
```
dashboard$ kubectl apply -f dashboard-deployment.yaml
image-predict$ kubectl apply -f image-predict-deployment.yaml
image-upload$ kubectl apply -f image-upload-deployment.yaml
```
Для "автоскейлинга", нужны комманды:
```
root$ kubectl autoscale deployment dashboard-deployment --max=5 --min=1 --cpu-percent=30
root$ kubectl autoscale deployment image-predict-deployment --max=5 --min=1 --cpu-percent=30
root$ kubectl autoscale deployment image-upload-deployment.yaml-deployment --max=5 --min=1 --cpu-percent=30
```
Image-upload сервис доступен на __localhost:8003__ и dashboard на __localhost:4400__
